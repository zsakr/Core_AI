import cv2
from ultralytics import YOLO
import supervision as sv
from collections import deque
import numpy as np
import torch
import time
import json
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from typing import List, Dict, Tuple, Optional
from inference.models.utils import get_model

# === Load Models ===
device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f"Using device: {device}")

# Load ball detection model
ball_model = get_model(
    model_id="squash_ball_detection-r1tts/1",
    api_key="QJen0rGApuNHlCEwrqfj"
)

# Load court detection model
court_model = get_model(
    model_id="squash_court/2",
    api_key="QJen0rGApuNHlCEwrqfj"
)
player_model = YOLO("yolov8s.pt")
pose_model = YOLO("yolov8x-pose.pt")
player_model.to(device)
pose_model.to(device)

# === Video Setup ===
input_video = "E:/Python/assets/input1.mp4"
output_video = "heatmap_output.mp4"

cap = cv2.VideoCapture(input_video)
if not cap.isOpened():
    print("Error opening video file")
    exit(1)

frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = cap.get(cv2.CAP_PROP_FPS)
frame_time = 1.0 / fps  # Use actual video FPS

out = cv2.VideoWriter(
    output_video,
    cv2.VideoWriter_fourcc(*'mp4v'),
    fps,
    (frame_width, frame_height)
)

# === Constants & Global Variables ===
# Shot type definitions
SHOT_TYPES = {
    'cross_court_drive': {
        'walls': ['front-wall-up' or 'front-wall-down'],
        'height_ratio': 0.3,
        'speed': 'fast',
        'direction': 'straight'
    },
    'straight_drive': {
        'walls': ['front-wall-up' or 'front-wall-down'],
        'height_ratio': 0.3,
        'speed': 'fast',
        'direction': 'cross'
    },
    'straight_lob': {
        'walls': ['front-wall-up'],
        'height_ratio': 0.8,
        'speed': 'slow',
        'direction': 'straight'
    },
    'cross_court_lob': {
        'walls': ['front-wall-up'],
        'height_ratio': 0.8,
        'speed': 'slow',
        'direction': 'cross'
    },
    'three_wall_boast': {
        'walls': ['side-wall', ('front-wall-up' or 'front-wall-down'), 'side-wall'],
        'height_ratio': 0.5,
        'speed': 'medium'
    },
    'two_wall_boast': {
        'walls': ['side-wall', 'front-wall-up' or 'front-wall-down'],
        'height_ratio': 0.5,
        'speed': 'medium'
    },
    'volley_straight': {
        'height_ratio': 0.6,
        'speed': 'fast',
        'direction': 'straight',
        'is_volley': True
    },
    'volley_cross': {
        'height_ratio': 0.6,
        'speed': 'fast',
        'direction': 'cross',
        'is_volley': True
    },
    'volley_drop': {
        'height_ratio': 0.3,
        'speed': 'slow',
        'walls': ['front-wall-up'],
        'is_volley': True
    },
    'volley_boast': {
        'walls': ['side-wall', 'front-wall-up'],
        'height_ratio': 0.5,
        'is_volley': True
    },
    'straight_drop': {
        'height_ratio': 0.2,
        'speed': 'slow',
        'walls': ['front-wall-up'],
        'direction': 'straight'
    },
    'cross_court_drop': {
        'height_ratio': 0.2,
        'speed': 'slow',
        'walls': ['front-wall-up'],
        'direction': 'cross'
    },
    'serve': {
        'height_ratio': 0.6,
        'walls': ['front-wall-up'],
        'direction': 'straight'
    }
}

# Standard squash court dimensions (meters)
COURT_WIDTH_M = 6.4
COURT_LENGTH_M = 9.75

# Initial pixels-per-meter (will be updated by court detection)
PIXELS_PER_METER = 100.0

# Bounce detection
CONTACT_COOLDOWN = 10         # frames between registering same wall contact

# Minimum shots to count rally
MIN_RALLY_SHOTS = 3

# Add at the top with other global variables
tin_contact_frames = 0
MIN_TIN_CONTACT_FRAMES = 3  # Ball must be in contact with tin for at least 3 frames

@dataclass
class ShotEvent:
    frame_number: int
    timestamp: float
    ball_position: tuple
    shot_type: str
    wall_contacted: str
    bounce_count: int
    player_position: Optional[tuple]
    player_id: Optional[int]
    bounce_frame: Optional[int] = None
    is_serve: bool = False
    player_color: Optional[str] = None

@dataclass
class RallyEvent:
    start_frame: int
    end_frame: Optional[int]
    start_time: float
    end_time: Optional[float]
    shots: List[ShotEvent]
    winner_id: Optional[int]
    end_reason: Optional[str]

# Initialize tracking state
frame_count = 0
prev_ball_pos = None
ball_history = []            # list of (frame_idx, timestamp, (x,y), (vx,vy))
player_history = []          # list of dicts with 'boxes', 'ids', 'colors'
wall_contact_history: Dict[str, tuple] = {}
wall_contact_cooldown: Dict[str, int] = {}
rally_history: List[RallyEvent] = []
current_rally: Optional[RallyEvent] = None
current_shot: Optional[ShotEvent] = None
bounce_count = 0
last_bounce_frame: Optional[int] = None
start_time = datetime.now()

player_colors: Dict[int, str] = {}

# HSV color ranges for shirt detection
COLOR_RANGES = {
    'red': [
        {'lower': np.array([0, 70, 50]), 'upper': np.array([10, 255, 255])},
        {'lower': np.array([160, 70, 50]), 'upper': np.array([180, 255, 255])}
    ],
    'blue': [{'lower': np.array([100, 70, 50]), 'upper': np.array([130, 255, 255])}],
    'green': [{'lower': np.array([40, 70, 50]), 'upper': np.array([80, 255, 255])}],
    'white': [{'lower': np.array([0, 0, 180]), 'upper': np.array([180, 30, 255])}],
    'black': [{'lower': np.array([0, 0, 0]), 'upper': np.array([180, 255, 70])}],
    'yellow': [{'lower': np.array([20, 70, 50]), 'upper': np.array([30, 255, 255])}],
    'gray': [{'lower': np.array([0, 0, 70]), 'upper': np.array([180, 30, 180])}]
}

# For drawing recent labels (shot types and rally winners)
drawn_labels = deque(maxlen=20)  # stores (frame_idx, text, (x, y))

# === Point Counting ===
point_scores: Dict[int, int] = {}  # {player_id: points}

# Function to draw scores on screen
def draw_scores(frame):
    if len(point_scores) == 0:
        return
    # Sort players by ID for consistent ordering
    sorted_ids = sorted(point_scores.keys())
    score_text = ""
    for pid in sorted_ids:
        score_text += f"P{pid}: {point_scores[pid]}   "
    cv2.putText(frame, score_text.strip(), (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)

# Utility Functions

def draw_recent_labels(frame, current_frame_idx):
    """
    Draw labels (shot types or rally winners) on the frame for a few frames.
    """
    for f_idx, text, (x, y) in drawn_labels:
        if current_frame_idx - f_idx < 15:  # show for 15 frames
            cv2.putText(
                frame,
                text,
                (int(x), int(y)),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.8,
                (255, 255, 0),
                2,
                cv2.LINE_AA
            )



def compute_iou(boxA, boxB):
    """
    Compute IoU between two bounding boxes [x1, y1, x2, y2].
    """
    xA = max(boxA[0], boxB[0])
    yA = max(boxA[1], boxB[1])
    xB = min(boxA[2], boxB[2])
    yB = min(boxA[3], boxB[3])
    interW = max(0, xB - xA)
    interH = max(0, yB - yA)
    interArea = interW * interH
    if interArea == 0:
        return 0.0
    boxAArea = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
    boxBArea = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])
    return interArea / float(boxAArea + boxBArea - interArea)


def get_shirt_hist(frame, box):
    """
    Compute normalized Hue histogram for upper third ("shirt") region of bounding box.
    """
    x1, y1, x2, y2 = box.astype(int)
    h = y2 - y1
    shirt_y2 = y1 + h // 3
    shirt_region = frame[y1:shirt_y2, x1:x2]
    if shirt_region.size == 0:
        return None
    hsv = cv2.cvtColor(shirt_region, cv2.COLOR_BGR2HSV)
    hist = cv2.calcHist([hsv], [0], None, [50], [0, 180])
    cv2.normalize(hist, hist, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX)
    return hist


def detect_shirt_color(frame, box):
    """
    Detect dominant shirt color in upper half of bounding box using HSV ranges.
    """
    x1, y1, x2, y2 = map(int, box)
    body_height = (y2 - y1) // 2
    body_region = frame[y1:y1+body_height, x1:x2]
    if body_region.size == 0:
        return None
    hsv = cv2.cvtColor(body_region, cv2.COLOR_BGR2HSV)
    max_pixels = 0
    dominant_color = None
    for color, ranges in COLOR_RANGES.items():
        total_pixels = 0
        for r in ranges:
            mask = cv2.inRange(hsv, r['lower'], r['upper'])
            total_pixels += cv2.countNonZero(mask)
        if total_pixels > max_pixels:
            max_pixels = total_pixels
            dominant_color = color
    min_pixels = (x2 - x1) * body_height * 0.1  # 10% of area
    return dominant_color if max_pixels > min_pixels else None


def get_closest_player(frame, ball_pos, player_boxes, player_ids, frame_width):
    """
    Find the closest player to the ball and detect their shirt color.
    Returns (player_id, position, color) or (None, None, None).
    """
    closest_dist = float('inf')
    closest_player = None
    closest_pos = None
    closest_color = None

    for i, box in enumerate(player_boxes):
        if i >= len(player_ids):
            continue
        pid = player_ids[i]
        x1, y1, x2, y2 = box.astype(int)
        player_pos = ((x1 + x2) // 2, y2)
        dist = np.hypot(player_pos[0] - ball_pos[0], player_pos[1] - ball_pos[1])
        if dist < closest_dist:
            color = detect_shirt_color(frame, box)
            if color:
                player_colors[pid] = color
            closest_dist = dist
            closest_player = pid
            closest_pos = player_pos
            closest_color = player_colors.get(pid)
    if closest_dist < frame_width / 4:
        return closest_player, closest_pos, closest_color
    return None, None, None


def detect_bounce(ball_history, frame_idx, min_points=5):
    """
    Detect a bounce if recent vertical velocities change from negative to positive.
    """
    if len(ball_history) < min_points:
        return False
    recent_vy = [p[3][1] for p in ball_history[-min_points:]]
    for i in range(1, len(recent_vy)):
        if recent_vy[i-1] < 0 and recent_vy[i] > 0:
            return True
    return False


def create_mask_from_points(points, shape):
    """
    Create a binary mask from polygon points.
    """
    pts = np.array([(p.x, p.y) for p in points], dtype=np.int32)
    mask = np.zeros(shape[:2], dtype=np.uint8)
    cv2.fillPoly(mask, [pts], 1)
    return mask


def classify_shot(ball_history, wall_contacts, fh, fw, is_first_shot=False):
    """
    Classify the shot type using ball positions and bounce detection.
    """
    if len(ball_history) < 3:
        return 'unknown'
    
    start_pos = ball_history[0][2]  # Initial position when hit
    end_pos = ball_history[-1][2]   # Final position when hit
    max_height = min(p[2][1] for p in ball_history)
    height_ratio = max_height / fh
    
    # Calculate court regions
    court_middle = fw / 2
    front_region = fw * 0.3  # Front 30% of court width
    low_height = fh * 0.3    # Lower 30% of court height
    
    # Determine if shot is in front court
    is_front_court = end_pos[0] < front_region
    # Determine if shot is low
    is_low_shot = end_pos[1] > (fh - low_height)
    
    # Check if it's a volley (hit before bounce)
    is_volley = False
    if current_shot and current_shot.bounce_frame:
        is_volley = (ball_history[-1][0] < current_shot.bounce_frame)
    
    # Determine shot direction
    start_side = 'left' if start_pos[0] < court_middle else 'right'
    end_side = 'left' if end_pos[0] < court_middle else 'right'
    direction = 'straight' if start_side == end_side else 'cross'
    
    # Calculate speed
    dx = end_pos[0] - start_pos[0]
    dy = end_pos[1] - start_pos[1]
    speed = np.hypot(dx, dy) / (len(ball_history) * frame_time)
    speed_type = 'fast' if speed > 15 else ('medium' if speed > 5 else 'slow')
    
    # First shot classification
    if is_first_shot and height_ratio > 0.5:
        return 'serve'
    
    # Drop shot detection
    if is_front_court and is_low_shot:
        if direction == 'straight':
            return 'straight_drop'
        else:
            return 'cross_court_drop'
    
    # Volley detection
    if is_volley:
        if is_front_court and is_low_shot:
            return 'volley_drop'
        elif direction == 'straight':
            return 'volley_straight'
        else:
            return 'volley_cross'
    
    # Regular shots
    if 'front-wall-up' in wall_contacts or 'front-wall-down' in wall_contacts:
        if height_ratio > 0.6:
            if direction == 'straight':
                return 'straight_lob'
            else:
                return 'cross_court_lob'
        else:
            if direction == 'straight':
                return 'straight_drive'
            else:
                return 'cross_court_drive'
    
    # Boast detection
    if 'left-wall' in wall_contacts or 'right-wall' in wall_contacts:
        if len([w for w in wall_contacts if 'wall' in w]) >= 2:
            return 'three_wall_boast'
        else:
            return 'two_wall_boast'
    
    return 'unknown'


def determine_rally_winner(rally: RallyEvent) -> Optional[int]:
    """
    Determine the rally winner based on the last shot and end_reason.
    The last player who hit the ball wins unless they hit the tin or the ball went out.
    """
    if not rally.shots:
        return None
    
    last_shot = rally.shots[-1]
    last_pid = last_shot.player_id
    
    if rally.end_reason == 'tin':
        # If the last player hit the tin, the other player wins
        for s in reversed(rally.shots[:-1]):
            if s.player_id != last_pid:
                return s.player_id
        return None
    elif rally.end_reason == 'double_bounce':
        # If double bounce, the last player wins
        return last_pid
    else:
        # For any other reason (like out of bounds), the last player wins
        return last_pid

# -------------------------------
# New function: Check if ball is near wrist
def is_ball_near_wrist(ball_pos, wrist_pos, threshold=100):  # Increased threshold from 50 to 100
    """
    Check if the ball is within a certain distance from the wrist position.
    """
    if wrist_pos is None or ball_pos is None:
        return False
    
    # Calculate distance between ball and wrist
    distance = np.hypot(ball_pos[0] - wrist_pos[0], ball_pos[1] - wrist_pos[1])
    
    # Print debug info
    print(f"Ball-Wrist Distance: {distance:.2f} pixels (threshold: {threshold})")
    
    return distance < threshold

# Modified update_rally_state to check rally start on ball near wrist
def update_rally_state(frame_count, ball_pos=None, bounce_detected=False, tin_hit=False, wrist_pos=None):
    """
    Update the current rally, handle bounce counts, and end rally if needed.
    Rally STARTS only if ball is near wrist and no rally ongoing.
    """
    global current_rally, bounce_count, rally_history, last_bounce_frame, point_scores

    if current_rally is None:
        # Start rally only if ball near wrist
        if ball_pos is not None and wrist_pos is not None:
            if is_ball_near_wrist(ball_pos, wrist_pos):
                print(f"Rally started at frame {frame_count}")
                elapsed_time = (datetime.now() - start_time).total_seconds()
                current_rally = RallyEvent(
                    start_frame=frame_count,
                    start_time=elapsed_time,
                    end_frame=None,
                    end_time=None,
                    shots=[],
                    winner_id=None,
                    end_reason=None
                )
                bounce_count = 0
        return

    if bounce_detected:
        bounce_count += 1
        last_bounce_frame = frame_count

    rally_ended = False
    end_reason = None
    if bounce_count >= 2:
        rally_ended = True
        end_reason = 'double_bounce'
    elif tin_hit:
        rally_ended = True
        end_reason = 'tin'

    if rally_ended and current_rally is not None:
        current_rally.end_frame = frame_count
        current_rally.end_time = (datetime.now() - start_time).total_seconds()
        current_rally.end_reason = end_reason
        current_rally.winner_id = determine_rally_winner(current_rally)

        if len(current_rally.shots) >= MIN_RALLY_SHOTS:
            rally_history.append(current_rally)
            # Increment point for winner
            wid = current_rally.winner_id
            if wid is not None:
                point_scores[wid] = point_scores.get(wid, 0) + 1
                winner_text = f"üèÜ Player {wid} wins"
                drawn_labels.append((frame_count, winner_text, (frame_width//2, 50)))
        current_rally = None
        bounce_count = 0
        last_bounce_frame = None

def draw_court_area(frame, x1, y1, x2, y2, label, conf, color):
    """
    Draw a semi-transparent overlay and label for a detected court area.
    """
    overlay = frame.copy()
    alpha = 0.3
    cv2.rectangle(overlay, (x1, y1), (x2, y2), color, -1)
    cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0, frame)

    text = f"{label} {conf}%"
    font_scale = 0.8
    thickness = 2
    font = cv2.FONT_HERSHEY_SIMPLEX
    text_size = cv2.getTextSize(text, font, font_scale, thickness)[0]
    text_x = x1 + (x2 - x1 - text_size[0]) // 2
    text_y = y1 + (y2 - y1 + text_size[1]) // 2

    cv2.rectangle(frame, (text_x - 10, text_y - text_size[1] - 10),
                  (text_x + text_size[0] + 10, text_y + 10), color, -1)
    cv2.putText(frame, text, (text_x, text_y), font, font_scale, (255, 255, 255), thickness)


def check_ball_wall_contact(ball_pos, wall_mask, wall_name, frame_count, frame):
    """
    Check if the ball has contacted a wall. If so, classify a shot
    (if in a rally) and record it.
    """
    global wall_contact_history, wall_contact_cooldown, current_shot, current_rally

    if wall_name in wall_contact_cooldown and frame_count - wall_contact_cooldown[wall_name] < CONTACT_COOLDOWN:
        return False

    x, y = map(int, ball_pos)
    if 0 <= y < wall_mask.shape[0] and 0 <= x < wall_mask.shape[1]:
        if wall_mask[y, x] > 0:
            wall_contact_history[wall_name] = ball_pos
            wall_contact_cooldown[wall_name] = frame_count

            if current_rally is not None:
                closest_player_id = None
                closest_player_pos = None
                closest_player_color = None
                for ph in reversed(player_history[-5:]):
                    pid, ppos, pcol = get_closest_player(
                        frame,
                        ball_pos,
                        ph['boxes'],
                        ph['ids'],
                        frame_width
                    )
                    if pid is not None:
                        closest_player_id = pid
                        closest_player_pos = ppos
                        closest_player_color = pcol
                        break

                is_first_shot = (len(current_rally.shots) == 0)
                shot_type = classify_shot(
                    ball_history,
                    list(wall_contact_history.keys()),
                    frame_height,
                    frame_width,
                    is_first_shot
                )

                current_shot = ShotEvent(
                    frame_number=frame_count,
                    timestamp=(datetime.now() - start_time).total_seconds(),
                    ball_position=ball_pos,
                    shot_type=shot_type,
                    wall_contacted=wall_name,
                    bounce_count=bounce_count,
                    player_position=closest_player_pos,
                    player_id=closest_player_id,
                    bounce_frame=last_bounce_frame if last_bounce_frame else None,
                    is_serve=(is_first_shot and shot_type == 'serve'),
                    player_color=closest_player_color
                )
                current_rally.shots.append(current_shot)

                if shot_type != "unknown":
                    drawn_labels.append((frame_count, shot_type, ball_pos))
            return True
    return False


def update_pixels_per_meter(frame, annotated_frame=None):
    """
    Detect the court in the frame and compute pixels-per-meter
    based on the 'floor' polygon. Optionally draw court overlays.
    """
    global PIXELS_PER_METER
    court_results = court_model.infer(frame)[0]
    if not hasattr(court_results, 'predictions') or len(court_results.predictions) == 0:
        return False

    floor_pred = None
    for pred in court_results.predictions:
        if pred.class_name == 'floor':
            floor_pred = pred
            break
    if floor_pred is None:
        return False

    floor_mask = create_mask_from_points(floor_pred.points, frame.shape)
    x_coords = np.where(np.any(floor_mask, axis=0))[0]
    y_coords = np.where(np.any(floor_mask, axis=1))[0]
    if len(x_coords) == 0 or len(y_coords) == 0:
        return False

    court_width_px = x_coords[-1] - x_coords[0]
    court_height_px = y_coords[-1] - y_coords[0]
    ppm_w = court_width_px / COURT_WIDTH_M
    ppm_h = court_height_px / COURT_LENGTH_M
    PIXELS_PER_METER = (ppm_w + ppm_h) / 2

    if annotated_frame is not None:
        colors = {
            'front-wall-up': (255, 0, 255),
            'front-wall-down': (0, 255, 255),
            'left-wall': (255, 0, 0),
            'right-wall': (0, 0, 255),
            'floor': (255, 255, 0),
            'tin': (128, 128, 0),
            'left-square': (255, 128, 0),
            'right-square': (0, 255, 255)
        }
        for pred in court_results.predictions:
            cname = pred.class_name
            if cname in colors:
                mask = create_mask_from_points(pred.points, frame.shape)
                xs = np.where(np.any(mask, axis=0))[0]
                ys = np.where(np.any(mask, axis=1))[0]
                if len(xs) > 0 and len(ys) > 0:
                    x1, x2 = xs[0], xs[-1]
                    y1, y2 = ys[0], ys[-1]
                    draw_court_area(
                        annotated_frame, x1, y1, x2, y2,
                        cname, int(pred.confidence * 100), colors[cname]
                    )
    return True

# === Annotators & Visuals ===
box_annotator = sv.BoxAnnotator()
label_annotator = sv.LabelAnnotator()
trail = deque(maxlen=5)
palette = sv.ColorPalette.DEFAULT

# === Heatmap Accumulators ===
heatmap_accum_1 = np.zeros((frame_height, frame_width), dtype=np.float32)
heatmap_accum_2 = np.zeros((frame_height, frame_width), dtype=np.float32)

# === Speed & Distance Tracking ===
prev_positions = {}      # Holds previous ankle positions per player ID
total_distances = {}     # {player_id: meters}

# For "one" mode: store shirt histogram of the target
target_shirt_hist = None

# === User Prompt: Track One or Both Players ===
track_mode = input("Track one or both players? (one/both): ").strip().lower()
if track_mode == "one":
    target_player_id = int(input("Which player do you want to track? (tracker_id): "))
    print("Processing video with heatmap and metrics for player ID:", target_player_id)
elif track_mode == "both":
    print("Processing video with heatmaps and metrics for both top players.")
else:
    raise ValueError("Invalid input. Please enter 'one' or 'both'.")

frame_index = 0

# Initialize court detection on first frame
ret, first_frame = cap.read()
if not ret:
    raise IOError("Could not read first frame")
rgb_first_frame = cv2.cvtColor(first_frame, cv2.COLOR_BGR2RGB)
first_frame_annotated = first_frame.copy()
if not update_pixels_per_meter(rgb_first_frame, first_frame_annotated):
    raise IOError("Could not detect court in first frame")
cv2.imwrite('first_frame_annotated.jpg', first_frame_annotated)
print(f"Initialized with {PIXELS_PER_METER:.2f} pixels per meter")

# === Main Processing Loop ===
try:
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        annotated_frame = frame.copy()

        # Detect court and build wall masks
        court_results = court_model.infer(rgb_frame)[0]
        wall_masks = {}
        if hasattr(court_results, 'predictions') and len(court_results.predictions) > 0:
            for pred in court_results.predictions:
                if pred.class_name in ['front-wall-up', 'front-wall-down', 'left-wall', 'right-wall', 'tin']:
                    wall_masks[pred.class_name] = create_mask_from_points(pred.points, rgb_frame.shape)

        # Periodically update pixels-per-meter and redraw court
        if frame_index % 30 == 0:
            if not update_pixels_per_meter(rgb_frame, annotated_frame):
                print("Warning: Could not detect court in frame")

        # --- Ball Detection ---
        ball_results = ball_model.infer(rgb_frame)[0]
        ball_detections = sv.Detections.from_inference(ball_results)

        # --- Player Detection & Tracking ---
        results = player_model.track(
            frame, persist=True, classes=[0], verbose=False, device=device
        )
        player_detections = sv.Detections.from_ultralytics(results[0])
        player_boxes = player_detections.xyxy.copy()
        player_ids = player_detections.tracker_id if player_detections.tracker_id is not None else []

        # --- Pose Estimation ---
        pose_results = pose_model(frame)[0]
        if hasattr(pose_results, "boxes") and pose_results.boxes is not None:
            pose_boxes = pose_results.boxes.xyxy.cpu().numpy()
            pose_kps = pose_results.keypoints.data.cpu().numpy()
        else:
            pose_boxes = np.zeros((0, 4))
            pose_kps = np.zeros((0, 17, 3))

        # Keep top-2 players by confidence if more than 2
        if len(player_boxes) > 2:
            top2 = np.argsort(player_detections.confidence)[-2:][::-1]
            player_boxes = player_boxes[top2]
            player_detections.xyxy = player_boxes
            player_detections.confidence = player_detections.confidence[top2]
            player_detections.class_id = player_detections.class_id[top2]
            if player_ids is not None:
                player_ids = [player_ids[i] for i in top2]

        # Save this frame's player boxes & IDs into history
        player_history.append({'boxes': player_boxes.copy(), 'ids': list(player_ids)})

        # --- Shadow Rendering Under Players ---
        overlay = frame.copy()
        for box in player_boxes:
            x1, y1, x2, y2 = box.astype(int)
            center_x = (x1 + x2) // 2
            center_y = y2 + 10
            width = int((x2 - x1) * 0.8)
            height = int((x2 - x1) * 0.25)
            y1_clip = np.clip(y1, 0, frame.shape[0])
            y2_clip = np.clip(y1 + (y2 - y1) // 4, 0, frame.shape[0])
            shirt_region = frame[y1_clip:y2_clip, x1:x2]
            if shirt_region.size == 0:
                shadow_color = (30, 30, 30)
            else:
                avg_color = shirt_region.mean(axis=(0, 1)).astype(int)
                b, g, r = avg_color
                factor = 1.3
                shadow_color = tuple(int(c) for c in np.clip(
                    [b * factor, g * factor, r * factor], 0, 255))
            cv2.ellipse(overlay, (center_x, center_y),
                        (width // 2, height), 0, 0, 360, shadow_color, -1)
        cv2.addWeighted(overlay, 0.7, annotated_frame, 0.3, 0, annotated_frame)

        # --- Ball Trail ---
        if len(ball_detections.xyxy) > 0:
            x1, y1, x2, y2 = ball_detections.xyxy[0]
            cx, cy = int((x1 + x2) / 2), int((y1 + y2) / 2)
            trail.append((cx, cy))
        for i in range(1, len(trail)):
            if trail[i - 1] and trail[i]:
                thickness = int(8 * (1 - i / len(trail))) + 1
                color = (0, 255 - i * 7, 255)
                cv2.line(annotated_frame, trail[i - 1], trail[i], color, thickness)

        # === Process Players: Heatmaps & Distances ===
        player_speeds = {}
        shirt_hists = [get_shirt_hist(frame, box) for box in player_boxes]

        # Identify target index if in "one" mode
        target_idx = None
        if track_mode == "one":
            if frame_index == 0:
                for i, tid in enumerate(player_ids):
                    if tid == target_player_id:
                        if shirt_hists[i] is not None:
                            target_shirt_hist = shirt_hists[i].copy()
                        target_idx = i
                        break
            else:
                best_score = -1.0
                best_i = -1
                for i, hist in enumerate(shirt_hists):
                    if hist is None or target_shirt_hist is None:
                        continue
                    score = cv2.compareHist(hist, target_shirt_hist, cv2.HISTCMP_CORREL)
                    if score > best_score:
                        best_score = score
                        best_i = i
                if best_score > 0.4:
                    target_idx = best_i
                else:
                    target_idx = None

        # Match player boxes to pose boxes via IoU
        matched_pose_idx = {}

        for i, box in enumerate(player_boxes):
            best_iou = 0.0
            best_j = -1
            for j, pbox in enumerate(pose_boxes):
                iou = compute_iou(box, pbox)
                if iou > best_iou:
                    best_iou = iou
                    best_j = j
            if best_iou > 0.3:
                matched_pose_idx[i] = best_j

        # Build current_positions for ankle coordinates
        current_positions = {}

        for i, box in enumerate(player_boxes):
            x1, y1, x2, y2 = box.astype(int)
            feet_x = (x1 + x2) // 2
            feet_y = y2

            draw_box = False
            if track_mode == "one":
                if i == target_idx:
                    draw_box = True
            else:  # both
                if i < 2:
                    draw_box = True
            if draw_box:
                cv2.rectangle(annotated_frame, (x1, y1), (x2, y2), (255, 0, 0), 2)

            # Heatmap update
            if track_mode == "one":
                if i == target_idx and 0 <= feet_x < frame_width and 0 <= feet_y < frame_height:
                    heatmap_accum_1[feet_y, feet_x] += 1.0
            else:
                if 0 <= feet_x < frame_width and 0 <= feet_y < frame_height:
                    if i == 0:
                        heatmap_accum_1[feet_y, feet_x] += 1.0
                    elif i == 1:
                        heatmap_accum_2[feet_y, feet_x] += 1.0

            # Ankle-based distance (direct)
            if ((track_mode == "one" and i == target_idx) or (track_mode == "both" and i < 2)):
                ankle_x = None
                ankle_y = None
                if i in matched_pose_idx:
                    j = matched_pose_idx[i]
                    person_kp = pose_kps[j]
                    lx, ly, lc = person_kp[15]  # left ankle
                    rx, ry, rc = person_kp[16]  # right ankle
                    if lc > 0.3 and rc > 0.3:
                        ankle_x = (lx + rx) / 2
                        ankle_y = (ly + ry) / 2
                    elif lc > 0.3:
                        ankle_x, ankle_y = lx, ly
                    elif rc > 0.3:
                        ankle_x, ankle_y = rx, ry
                if ankle_x is None or ankle_y is None:
                    ankle_x = float(feet_x)
                    ankle_y = float(feet_y)

                pid = player_ids[i]
                current_positions[pid] = (ankle_x, ankle_y)

                # Compute distance from previous position if available
                if pid in prev_positions:
                    prev_x, prev_y = prev_positions[pid]
                    dist_px = np.hypot(ankle_x - prev_x, ankle_y - prev_y)
                    dist_m = dist_px / PIXELS_PER_METER
                    if 0.05 < dist_m < 1.0:
                        total_distances[pid] = total_distances.get(pid, 0.0) + dist_m
                        player_speeds[pid] = dist_m / frame_time
                    else:
                        player_speeds[pid] = 0.0
                else:
                    player_speeds[pid] = 0.0
                    total_distances[pid] = total_distances.get(pid, 0.0)

                cv2.circle(annotated_frame, (int(ankle_x), int(ankle_y)), 4, (255, 0, 0), -1)
            else:
                if i < len(player_ids):
                    pid = player_ids[i]
                    total_distances[pid] = total_distances.get(pid, 0.0)
                    player_speeds[pid] = 0.0

        prev_positions = current_positions.copy()

        # --- Ball Detection & Tracking ---
        ball_speed = 0.0
        if len(ball_detections.xyxy) > 0:
            x1, y1, x2, y2 = ball_detections.xyxy[0]
            ball_pos = (int((x1 + x2) / 2), int((y1 + y2) / 2))

            if prev_ball_pos is not None:
                dx = (ball_pos[0] - prev_ball_pos[0]) / frame_time
                dy = (ball_pos[1] - prev_ball_pos[1]) / frame_time
                velocity = (dx, dy)
                ball_speed = np.hypot(dx, dy) / PIXELS_PER_METER
            else:
                velocity = (0, 0)
                ball_speed = 0.0

            elapsed_time = (datetime.now() - start_time).total_seconds()
            ball_history.append((frame_index, elapsed_time, ball_pos, velocity))

            tin_hit = False
            bounce_detected = False

            cv2.circle(annotated_frame, tuple(map(int, ball_pos)), 5, (0, 255, 255), -1)
            if prev_ball_pos is not None:
                cv2.line(annotated_frame, tuple(map(int, prev_ball_pos)), tuple(map(int, ball_pos)), (0, 255, 255), 2)
                for wname, wmask in wall_masks.items():
                    if check_ball_wall_contact(ball_pos, wmask, wname, frame_index, rgb_frame):
                        print(f"Ball contact with {wname}")
                        if wname == 'tin':
                            tin_contact_frames += 1
                            if tin_contact_frames >= MIN_TIN_CONTACT_FRAMES:
                                tin_hit = True
                                print(f"Tin hit confirmed at frame {frame_index} after {tin_contact_frames} frames of contact")
                        else:
                            tin_contact_frames = 0  # Reset tin contact counter if ball hits other wall
                    else:
                        if wname == 'tin':
                            tin_contact_frames = 0  # Reset tin contact counter if ball is not touching tin

                for wname, pos in list(wall_contact_history.items()):
                    since = frame_index - wall_contact_cooldown[wname]
                    if since < CONTACT_COOLDOWN:
                        x, y = map(int, pos)
                        color_map = {
                            'front-wall-up': (255, 0, 255),
                            'front-wall-down': (0, 255, 255),
                            'left-wall': (255, 0, 0),
                            'right-wall': (0, 0, 255),
                            'tin': (128, 128, 0)
                        }
                        cv2.circle(annotated_frame, (x, y), 20 - 2*since, color_map.get(wname, (0, 255, 0)), 2)
                    else:
                        del wall_contact_history[wname]

            # Extract wrist position(s) to check rally start
            wrist_pos_to_use = None
            min_wrist_dist = float('inf')
            for i, pid in enumerate(player_ids):
                if i not in matched_pose_idx:
                    continue
                j = matched_pose_idx[i]
                person_kp = pose_kps[j]
                # Left and right wrist indices in COCO format: 9 - left wrist, 10 - right wrist
                lw_x, lw_y, lw_c = person_kp[9]
                rw_x, rw_y, rw_c = person_kp[10]
                ball_x, ball_y = ball_pos
                # Check distances and pick closest wrist with confidence > 0.3
                if lw_c > 0.3:
                    dist_lw = np.hypot(lw_x - ball_x, lw_y - ball_y)
                    if dist_lw < min_wrist_dist:
                        wrist_pos_to_use = (lw_x, lw_y)
                        min_wrist_dist = dist_lw
                if rw_c > 0.3:
                    dist_rw = np.hypot(rw_x - ball_x, rw_y - ball_y)
                    if dist_rw < min_wrist_dist:
                        wrist_pos_to_use = (rw_x, rw_y)
                        min_wrist_dist = dist_rw

            bounce_detected = detect_bounce(ball_history, frame_index)

            update_rally_state(
                frame_count=frame_index,
                ball_pos=ball_pos,
                bounce_detected=bounce_detected,
                tin_hit=tin_hit,
                wrist_pos=wrist_pos_to_use
            )

            prev_ball_pos = ball_pos
        else:
            ball_speed = 0.0
            prev_ball_pos = None

        # --- Heatmap Overlay ---
        if track_mode == "one":
            combined_heatmap = heatmap_accum_1
        else:
            combined_heatmap = heatmap_accum_1 + heatmap_accum_2

        heatmap_norm = cv2.normalize(combined_heatmap, None, 0, 255, cv2.NORM_MINMAX)
        heatmap_uint8 = heatmap_norm.astype(np.uint8)
        heatmap_color = cv2.applyColorMap(heatmap_uint8, cv2.COLORMAP_HOT)
        overlay_heatmap = cv2.addWeighted(annotated_frame, 0.7, heatmap_color, 0.3, 0)

        # --- Display Metrics & Shot/Winner Labels & Scores ---
        x_text = frame_width - 10
        y_text = 30
        line_height = 25
        MS_TO_MPH = 2.23694

        if track_mode == "one":
            speed_mps = player_speeds.get(target_player_id, 0.0)
            speed_mph = speed_mps * MS_TO_MPH
            dist_val = total_distances.get(target_player_id, 0.0)
            ball_mph = ball_speed * MS_TO_MPH

            current_shot_type = "unknown"
            current_player_color = player_colors.get(target_player_id, "unknown")
            if current_rally and current_rally.shots:
                last = current_rally.shots[-1]
                current_shot_type = last.shot_type
                if last.player_color:
                    current_player_color = last.player_color

            metrics_text = [
                f"Player ID: {target_player_id} ({current_player_color})",
                f"Player Speed: {speed_mph:.2f} mph",
                f"Distance Moved: {dist_val:.2f} m",
                f"Ball Speed: {ball_mph:.2f} mph",
                f"Shot Type: {current_shot_type}"
            ]
        else:
            ball_mph = ball_speed * MS_TO_MPH
            current_shot_type = "unknown"
            current_player_color = "unknown"
            if current_rally and current_rally.shots:
                last = current_rally.shots[-1]
                current_shot_type = last.shot_type
                current_player_color = last.player_color or "unknown"

            metrics_text = [
                f"Ball Speed: {ball_mph:.2f} mph",
                f"Shot Type: {current_shot_type}",
                f"Last Hit By: {current_player_color}"
            ]
            for i, pid in enumerate(player_ids[:2]):
                speed_mps = player_speeds.get(pid, 0.0)
                speed_mph = speed_mps * MS_TO_MPH
                dist_val = total_distances.get(pid, 0.0)
                player_color = player_colors.get(pid, "unknown")
                metrics_text.append(f"Player {pid} ({player_color}) Speed: {speed_mph:.2f} mph")
                metrics_text.append(f"Player {pid} Dist: {dist_val:.2f} m")

        # Draw scores at top-left
        draw_scores(overlay_heatmap)

        for i, line in enumerate(metrics_text):
            text_size, _ = cv2.getTextSize(line, cv2.FONT_HERSHEY_SIMPLEX, 0.7, 2)
            text_w, _ = text_size
            cv2.putText(
                overlay_heatmap,
                line,
                (x_text - text_w, y_text + i * line_height),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.7,
                (0, 255, 255),
                2,
                cv2.LINE_AA
            )

        # Draw pose keypoints for tracked players
        if hasattr(pose_results, "keypoints") and pose_results.keypoints is not None:
            for i, pid in enumerate(player_ids):
                if (track_mode == "one" and i != target_idx) or (track_mode == "both" and i not in [0, 1]):
                    continue
                if i not in matched_pose_idx:
                    continue
                j = matched_pose_idx[i]
                person_kp = pose_kps[j]
                for keypoint in person_kp:
                    x, y, conf = keypoint
                    if conf > 0.5:
                        cv2.circle(overlay_heatmap, (int(x), int(y)), 5, (0, 255, 0), -1)

        # Draw recent shot & winner labels
        draw_recent_labels(overlay_heatmap, frame_index)

        # Draw rally status
        rally_status = "rally status: started" if current_rally is not None else "rally status: ended"
        status_text_size, _ = cv2.getTextSize(rally_status, cv2.FONT_HERSHEY_SIMPLEX, 0.8, 2)
        status_x = (frame_width - status_text_size[0]) // 2  # Center horizontally
        cv2.putText(
            overlay_heatmap,
            rally_status,
            (status_x, 60),  # Position below the scores
            cv2.FONT_HERSHEY_SIMPLEX,
            0.8,
            (0, 255, 255),  # Yellow color
            2,
            cv2.LINE_AA
        )

        # Show and write frame
        cv2.imshow('Real-time Tracking', overlay_heatmap)
        out.write(overlay_heatmap)

        frame_index += 1

        # Export rally data and break on 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_data = {
                'start_time': start_time.isoformat(),
                'video_file': input_video,
                'rallies': [{
                    'start_frame': r.start_frame,
                    'end_frame': r.end_frame,
                    'start_time': (start_time + timedelta(seconds=r.start_time)).isoformat(),
                    'end_time': (start_time + timedelta(seconds=r.end_time)).isoformat() if r.end_time else None,
                    'shots': [{
                        **asdict(s),
                        'timestamp': (start_time + timedelta(seconds=s.timestamp)).isoformat()
                    } for s in r.shots],
                    'winner_id': r.winner_id,
                    'end_reason': r.end_reason
                } for r in rally_history]
            }
            with open('match_data.json', 'w') as f:
                json.dump(output_data, f, indent=2)
            print(f"\nExported {len(rally_history)} rallies to match_data.json")
            break

finally:
    cap.release()
    out.release()
    cv2.destroyAllWindows()
    print(f"Processing complete. Output saved as {output_video}")

